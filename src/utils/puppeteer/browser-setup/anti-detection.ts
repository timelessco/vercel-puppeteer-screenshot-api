// * Reference: https://intoli.com/blog/not-possible-to-block-chrome-headless/
// ! Generated by Claude Opus 4.1 based on the above reference

/* eslint-disable @eslint-community/eslint-comments/disable-enable-pair */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unnecessary-condition */
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
/* eslint-disable @typescript-eslint/unbound-method */
/* eslint-disable @typescript-eslint/no-unsafe-function-type */
/* eslint-disable @typescript-eslint/require-await */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
/* eslint-disable logical-assignment-operators */

import type { SetupBrowserPageOptions } from "./index";

type ApplyAntiDetectionEvasionsOptions = SetupBrowserPageOptions;

/**
 * Applies comprehensive anti-detection evasions to make the browser appear more human-like.
 * These evasions help pass bot detection tests by overriding telltale automation properties.
 * This should be called BEFORE any page navigation to ensure evasions are in place.
 *
 * Enhanced for 2025 with latest anti-detection techniques to bypass modern detection methods.
 * @param {ApplyAntiDetectionEvasionsOptions} options - Configuration options for anti-detection evasions
 * @returns {Promise<void>}
 */
export async function applyAntiDetectionEvasions(
	options: ApplyAntiDetectionEvasionsOptions,
): Promise<void> {
	const { logger, page } = options;
	logger.info("Applying comprehensive anti-detection evasions");

	// Remove CDP runtime indicators
	await page.evaluateOnNewDocument(() => {
		// Remove Runtime.enable indicators
		if ((globalThis as any).chrome && (globalThis as any).chrome.runtime) {
			const originalRuntime = (globalThis as any).chrome.runtime;
			(globalThis as any).chrome.runtime = new Proxy(originalRuntime, {
				get(target, prop) {
					if (prop === "id") return;
					return target[prop];
				},
			});
		}
	});

	// Override navigator properties and browser APIs before any page loads
	await page.evaluateOnNewDocument(() => {
		// ========================================
		// 1. CORE NAVIGATOR EVASIONS
		// ========================================

		// Fix webdriver property - most basic detection
		// Use delete first to ensure clean override
		try {
			delete (navigator as any).__proto__.webdriver;
		} catch {
			// Ignore error if delete fails
		}

		Object.defineProperty(navigator, "webdriver", {
			configurable: true,
			enumerable: false,
			get: () => {},
		});

		// Fix vendor for Chrome browsers
		Object.defineProperty(navigator, "vendor", {
			configurable: true,
			get: () => "Google Inc.",
		});

		// Fix plugins to appear populated with realistic plugins
		// Delete existing to ensure clean override
		try {
			delete (navigator as any).__proto__.plugins;
		} catch {
			// Ignore error if delete fails
		}

		// Create proper PluginArray mock that passes detection
		const pluginData = [
			{
				description: "Portable Document Format",
				filename: "internal-pdf-viewer",
				mimeTypes: [
					{
						description: "Portable Document Format",
						suffixes: "pdf",
						type: "application/pdf",
					},
					{
						description: "Portable Document Format",
						suffixes: "pdf",
						type: "text/pdf",
					},
				],
				name: "Chrome PDF Plugin",
			},
			{
				description: "Portable Document Format",
				filename: "mhjfbmdgcfjbbpaeojofohoefgiehjai",
				mimeTypes: [
					{
						description: "Portable Document Format",
						suffixes: "pdf",
						type: "application/pdf",
					},
				],
				name: "Chrome PDF Viewer",
			},
		];

		// Create plugins array with proper prototype chain
		const PluginArray = (globalThis as any).PluginArray || Array;
		const plugins = Object.create(PluginArray.prototype);

		pluginData.forEach((p, index) => {
			const Plugin = (globalThis as any).Plugin || Object;
			const plugin = Object.create(Plugin.prototype);

			// Set plugin properties
			Object.defineProperties(plugin, {
				description: { enumerable: true, value: p.description },
				filename: { enumerable: true, value: p.filename },
				length: { enumerable: true, value: p.mimeTypes.length },
				name: { enumerable: true, value: p.name },
			});

			// Add MimeType entries
			const MimeTypeArray = (globalThis as any).MimeTypeArray || Array;
			const mimeTypes = Object.create(MimeTypeArray.prototype);

			p.mimeTypes.forEach((m, i) => {
				const MimeType = (globalThis as any).MimeType || Object;
				const mimeType = Object.create(MimeType.prototype);

				Object.defineProperties(mimeType, {
					description: { enumerable: true, value: m.description },
					enabledPlugin: { enumerable: true, value: plugin },
					suffixes: { enumerable: true, value: m.suffixes },
					type: { enumerable: true, value: m.type },
				});

				mimeTypes[i] = mimeType;
			});

			Object.defineProperty(mimeTypes, "length", { value: p.mimeTypes.length });
			mimeTypes.item = (index: number) => mimeTypes[index] || null;
			mimeTypes.namedItem = (name: string) => {
				for (const mimeType of mimeTypes) {
					if (mimeType.type === name) return mimeType;
				}
				return null;
			};

			// Add mimeTypes to plugin
			for (let i = 0; i < p.mimeTypes.length; i++) {
				plugin[i] = mimeTypes[i];
			}

			plugin.item = (index: number) => plugin[index] || null;
			plugin.namedItem = (name: string) => mimeTypes.namedItem(name);

			// Add plugin to array
			plugins[index] = plugin;
		});

		// Set PluginArray properties
		Object.defineProperty(plugins, "length", {
			configurable: true,
			enumerable: false,
			value: pluginData.length,
		});

		plugins.item = (index: number) => plugins[index] || null;
		plugins.namedItem = (name: string) => {
			for (const plugin of plugins) {
				if (plugin && plugin.name === name) return plugin;
			}
			return null;
		};
		plugins.refresh = () => {};

		// Override navigator.plugins
		Object.defineProperty(navigator, "plugins", {
			configurable: true,
			enumerable: true,
			get: () => plugins,
		});

		// Enhanced permissions handling
		const originalQuery = globalThis.navigator.permissions.query.bind(
			globalThis.navigator.permissions,
		);

		globalThis.navigator.permissions.query = async function (parameters: any) {
			if (parameters.name === "notifications") {
				return { state: "denied" } as PermissionStatus;
			}

			if (parameters.name === "push") {
				return { state: "prompt" } as PermissionStatus;
			}

			if (parameters.name === "midi" || parameters.name === "camera") {
				return { state: "prompt" } as PermissionStatus;
			}

			if (parameters.name === "microphone") {
				return { state: "prompt" } as PermissionStatus;
			}

			return originalQuery(parameters);
		};

		// Fix languages to be more realistic
		Object.defineProperty(navigator, "languages", {
			configurable: true,
			get: () => ["en-US", "en"],
		});

		// Hardware concurrency - use common values
		Object.defineProperty(navigator, "hardwareConcurrency", {
			configurable: true,
			get: () => 8,
		});

		// Platform detection - will be overridden later based on user agent
		Object.defineProperty(navigator, "platform", {
			configurable: true,
			get: () => {
				const userAgent = navigator.userAgent.toLowerCase();
				if (userAgent.includes("win")) return "Win32";
				if (userAgent.includes("mac")) return "MacIntel";
				if (userAgent.includes("linux")) {
					if (userAgent.includes("x86_64")) return "Linux x86_64";
					return "Linux";
				}
				return "MacIntel"; // Default fallback
			},
		});

		// Add connection API

		if (!(navigator as any).connection) {
			(navigator as any).connection = {
				addEventListener: () => {},

				dispatchEvent: () => {},
				downlink: 10,
				downlinkMax: undefined,
				effectiveType: "4g",

				removeEventListener: () => {},
				rtt: 100,
				saveData: false,
				type: "wifi",
			};
		}

		// Mock battery API to prevent fingerprinting

		if ((navigator as any).getBattery) {
			(navigator as any).getBattery = async () => ({
				addEventListener: () => {},
				charging: true,
				chargingTime: 0,
				dischargingTime: Infinity,

				dispatchEvent: () => {},
				level: 1,

				removeEventListener: () => {},
			});
		}

		// Mock media devices

		if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
			navigator.mediaDevices.enumerateDevices = async () => [
				{
					deviceId: "default",
					groupId: "default-group",
					kind: "audioinput" as MediaDeviceKind,
					label: "Default Audio Device",
					toJSON: () => ({}),
				},
				{
					deviceId: "communications",
					groupId: "communications-group",
					kind: "audioinput" as MediaDeviceKind,
					label: "Communications Audio Device",
					toJSON: () => ({}),
				},
				{
					deviceId: "default-speaker",
					groupId: "default-group",
					kind: "audiooutput" as MediaDeviceKind,
					label: "Default Speaker",
					toJSON: () => ({}),
				},
			];
		}

		// ========================================
		// 2. CHROME OBJECT ENHANCEMENTS
		// ========================================

		// Enhance Chrome object to be more complete

		if (!(globalThis as any).chrome) {
			(globalThis as any).chrome = {};
		}

		const chrome = (globalThis as any).chrome;

		// Add chrome.runtime with realistic structure
		if (!chrome.runtime) {
			chrome.runtime = {
				connect: () => {},
				id: undefined,

				sendMessage: () => {},
			};
		}

		// Fix chrome.csi
		chrome.csi = () => ({
			onloadT: Date.now() - 2000,
			pageT: Date.now() - 1000,
			startE: Date.now() - 3000,
			tran: 15,
		});

		// Fix chrome.loadTimes
		chrome.loadTimes = () => ({
			commitLoadTime: Date.now() / 1000 - 2.3,
			connectionInfo: "h2",
			finishDocumentLoadTime: Date.now() / 1000 - 0.5,
			finishLoadTime: Date.now() / 1000 - 0.2,
			firstPaintAfterLoadTime: 0,
			firstPaintTime: Date.now() / 1000 - 1.5,
			navigationType: "Other",
			npnNegotiatedProtocol: "h2",
			requestTime: Date.now() / 1000 - 3,
			startLoadTime: Date.now() / 1000 - 2.5,
			wasAlternateProtocolAvailable: false,
			wasFetchedViaSpdy: false,
			wasNpnNegotiated: true,
		});

		// Add chrome.app
		if (!chrome.app) {
			chrome.app = {
				getDetails: () => {},

				getIsInstalled: () => {},

				installState: () => {},
				isInstalled: false,
				runningState: () => "running",
			};
		}

		// ========================================
		// 3. WEBGL & CANVAS FINGERPRINTING PROTECTION
		// ========================================

		// Override WebGL vendor and renderer
		const getParameter = WebGLRenderingContext.prototype.getParameter;
		WebGLRenderingContext.prototype.getParameter = function (parameter) {
			// UNMASKED_VENDOR_WEBGL
			if (parameter === 37_445) {
				return "Intel Inc.";
			}
			// UNMASKED_RENDERER_WEBGL
			if (parameter === 37_446) {
				return "Intel Iris OpenGL Engine";
			}
			// eslint-disable-next-line prefer-rest-params
			return getParameter.apply(this, arguments as never);
		};

		const getParameter2 = WebGL2RenderingContext.prototype.getParameter;
		WebGL2RenderingContext.prototype.getParameter = function (parameter) {
			// UNMASKED_VENDOR_WEBGL
			if (parameter === 37_445) {
				return "Intel Inc.";
			}
			// UNMASKED_RENDERER_WEBGL
			if (parameter === 37_446) {
				return "Intel Iris OpenGL Engine";
			}
			// eslint-disable-next-line prefer-rest-params
			return getParameter2.apply(this, arguments as never);
		};

		// Add noise to canvas to prevent fingerprinting
		const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
		HTMLCanvasElement.prototype.toDataURL = function (...args) {
			const context = this.getContext("2d");
			if (context) {
				// Add minimal noise that won't affect visual appearance
				const imageData = context.getImageData(0, 0, this.width, this.height);
				const data = imageData.data;
				for (let i = 0; i < data.length; i += 4) {
					// Add tiny noise to alpha channel (usually invisible)
					data[i + 3] = Math.min(255, data[i + 3] + Math.random() * 0.1);
				}
				context.putImageData(imageData, 0, 0);
			}

			return originalToDataURL.apply(this, args);
		};

		// ========================================
		// 4. WINDOW & SCREEN PROPERTIES
		// ========================================

		// Fix window outer dimensions
		Object.defineProperty(globalThis, "outerWidth", {
			configurable: true,
			get: () => window.innerWidth,
		});

		Object.defineProperty(globalThis, "outerHeight", {
			configurable: true,
			get: () => window.innerHeight + 85, // Account for browser chrome
		});

		// Screen dimensions consistency
		Object.defineProperty(screen, "availWidth", {
			configurable: true,
			get: () => screen.width,
		});

		Object.defineProperty(screen, "availHeight", {
			configurable: true,
			get: () => screen.height - 30, // Account for taskbar
		});

		// Device pixel ratio
		Object.defineProperty(globalThis, "devicePixelRatio", {
			configurable: true,
			get: () => 1,
		});

		// ========================================
		// 5. ADVANCED DETECTION BYPASS
		// ========================================

		// Override toString to hide modifications
		const originalToString = Function.prototype.toString;

		Function.prototype.toString = function (this: Function) {
			if (this === globalThis.navigator.permissions.query) {
				return "function query() { [native code] }";
			}
			if (this === HTMLCanvasElement.prototype.toDataURL) {
				return "function toDataURL() { [native code] }";
			}
			if (this === WebGLRenderingContext.prototype.getParameter) {
				return "function getParameter() { [native code] }";
			}
			return originalToString.call(this);
		};

		// Fix Intl.DateTimeFormat timezone
		const DateTimeFormat = Intl.DateTimeFormat;

		Intl.DateTimeFormat = function (...args: any[]) {
			const instance = new DateTimeFormat(...args);
			const resolvedOptions = instance.resolvedOptions.bind(instance);
			instance.resolvedOptions = function () {
				const options = resolvedOptions();
				// Set to a common timezone
				options.timeZone ||= "America/New_York";
				return options;
			};
			return instance;
		} as any;
		// Copy over prototype properties without reassigning
		Object.setPrototypeOf(Intl.DateTimeFormat, DateTimeFormat);
		Object.setPrototypeOf(
			Intl.DateTimeFormat.prototype,
			DateTimeFormat.prototype,
		);
		Intl.DateTimeFormat.supportedLocalesOf = DateTimeFormat.supportedLocalesOf;

		// WebRTC leak prevention

		if (globalThis.RTCPeerConnection) {
			const OriginalRTCPeerConnection = globalThis.RTCPeerConnection;

			globalThis.RTCPeerConnection = function (...args: any[]) {
				const pc = new OriginalRTCPeerConnection(...args);
				// Override createDataChannel to prevent WebRTC enumeration
				pc.createDataChannel = function () {
					return {
						close: () => {},
						readyState: "closed",

						send: () => {},
					} as any;
				};
				return pc;
			} as any;
			globalThis.RTCPeerConnection.prototype =
				OriginalRTCPeerConnection.prototype;
		}

		// Hide stack traces that might reveal automation
		const originalError = Error;

		globalThis.Error = function (...args: any[]) {
			const error = new originalError(...args);
			// Clean stack trace of puppeteer references
			error.stack &&= error.stack
				.split("\n")
				.filter(
					(line) =>
						!line.includes("puppeteer") &&
						!line.includes("rebrowser") &&
						!line.includes("evaluateOnNewDocument"),
				)
				.join("\n");
			return error;
		} as any;
		// Copy over prototype properties without reassigning
		Object.setPrototypeOf(globalThis.Error, originalError);
		Object.setPrototypeOf(globalThis.Error.prototype, originalError.prototype);

		// Fix console.debug (often checked by anti-bot systems)
		const originalConsoleDebug = console.debug;

		console.debug = function (...args: any[]) {
			// Filter out certain debug messages that might reveal automation

			const msg = args[0]?.toString() || "";

			if (
				msg.includes("puppeteer") ||
				msg.includes("rebrowser") ||
				msg.includes("HeadlessChrome")
			) {
				return;
			}

			originalConsoleDebug.apply(console, args);
		};

		// ========================================
		// 6. PERFORMANCE & TIMING EVASIONS
		// ========================================

		// Add realistic performance timing

		if (globalThis.performance && (performance as any).memory) {
			Object.defineProperty(performance, "memory", {
				configurable: true,
				get: () => ({
					jsHeapSizeLimit: 2_172_649_472,
					totalJSHeapSize: 35_324_116,
					usedJSHeapSize: 30_590_116,
				}),
			});
		}

		// ========================================
		// 7. MISCELLANEOUS EVASIONS
		// ========================================

		// Fix navigator.maxTouchPoints for consistency
		Object.defineProperty(navigator, "maxTouchPoints", {
			configurable: true,
			get: () => 0, // Desktop browser
		});

		// Add Bluetooth API mock (if not present)

		if (!(navigator as any).bluetooth) {
			(navigator as any).bluetooth = {
				addEventListener: () => {},

				dispatchEvent: () => {},
				getAvailability: () => Promise.resolve(false),

				removeEventListener: () => {},
			};
		}

		// Mock clipboard API
		if (!navigator.clipboard) {
			(navigator as any).clipboard = {
				readText: () => Promise.reject(new Error("Clipboard access denied")),
				writeText: () => Promise.resolve(),
			};
		}

		// Fix history.length to appear more natural
		if (globalThis.history && globalThis.history.length === 1) {
			const descriptor = Object.getOwnPropertyDescriptor(
				History.prototype,
				"length",
			);
			if (descriptor?.get) {
				Object.defineProperty(History.prototype, "length", {
					configurable: true,
					get: () => 2 + Math.floor(Math.random() * 4), // Random between 2-5
				});
			}
		}

		// Mock speech synthesis (if needed)
		if (!globalThis.speechSynthesis) {
			(globalThis as any).speechSynthesis = {
				cancel: () => {},
				getVoices: () => [],

				pause: () => {},
				paused: false,
				pending: false,

				resume: () => {},

				speak: () => {},
				speaking: false,
			};
		}
	});

	// Set a more realistic user agent without automation indicators
	const userAgent = await page.evaluate(() => navigator.userAgent);

	// Clean up the user agent string
	let fixedUserAgent = userAgent
		.replace("HeadlessChrome", "Chrome")
		.replace("Headless", "");

	// Ensure the user agent has realistic OS information
	if (fixedUserAgent.includes("(")) {
		// Clean up existing OS info
		fixedUserAgent = fixedUserAgent.replace(/\([^)]+\)/, (match) => {
			// If it contains automation-related keywords, replace with clean OS info
			if (match.includes("Headless") || match.includes("HeadlessChrome")) {
				const platform = process.platform;
				if (platform === "darwin") {
					return "(Macintosh; Intel Mac OS X 10_15_7)";
				} else if (platform === "win32") {
					return "(Windows NT 10.0; Win64; x64)";
				} else {
					return "(X11; Linux x86_64)";
				}
			}
			return match;
		});
	} else {
		// If no OS info, add it based on platform
		const platform = process.platform;
		if (platform === "darwin") {
			fixedUserAgent = fixedUserAgent.replace(
				"Mozilla/5.0",
				"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)",
			);
		} else if (platform === "win32") {
			fixedUserAgent = fixedUserAgent.replace(
				"Mozilla/5.0",
				"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)",
			);
		} else {
			fixedUserAgent = fixedUserAgent.replace(
				"Mozilla/5.0",
				"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)",
			);
		}
	}

	await page.setUserAgent(fixedUserAgent);

	// Set additional HTTP headers for more realistic browsing
	await page.setExtraHTTPHeaders({
		Accept:
			"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
		"Accept-Encoding": "gzip, deflate, br",
		"Accept-Language": "en-US,en;q=0.9",
	});

	// Note: Viewport should be set in browser-setup/index.ts with DEFAULT_VIEWPORT
	// We don't set it here to avoid conflicts with the standard setup

	logger.info("Comprehensive anti-detection evasions applied successfully", {
		userAgent: fixedUserAgent,
	});
}

type ApplyCDPWebdriverRemovalOptions = SetupBrowserPageOptions;

/**
 * Applies early CDP-level webdriver removal before any page scripts load.
 * This is the most critical anti-detection measure as it removes webdriver
 * at the protocol level before JavaScript execution begins.
 * @param {ApplyCDPWebdriverRemovalOptions} options - Configuration options for CDP webdriver removal
 * @returns {Promise<void>}
 */
export async function applyCDPWebdriverRemoval(
	options: ApplyCDPWebdriverRemovalOptions,
): Promise<void> {
	const { logger, page } = options;

	try {
		const client = await page.createCDPSession();
		await client.send("Page.addScriptToEvaluateOnNewDocument", {
			source: `
				// Remove webdriver at the earliest possible stage
				delete Object.getPrototypeOf(navigator).webdriver;

				// Ensure chrome automation is hidden
				if (window.chrome) {
					window.chrome.runtime = window.chrome.runtime || {};
					Object.defineProperty(window.chrome.runtime, 'id', {
						get: () => undefined
					});
				}
			`,
		});
	} catch (error) {
		logger.warn("CDP script injection failed", { error });
	}
}
